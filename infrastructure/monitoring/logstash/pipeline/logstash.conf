# KillKrill Logstash Pipeline Configuration
# Process logs from Redis Streams and forward to Elasticsearch

input {
  # Redis Streams input for logs
  redis {
    host => "redis"
    port => 6379
    password => "${REDIS_PASSWORD:killkrill123}"
    data_type => "stream"
    key => "logs:processed"
    consumer_group => "logstash-consumers"
    consumer => "logstash-1"
    codec => json
    tags => ["killkrill", "logs", "redis-stream"]
  }

  # Optional: Direct syslog input for legacy systems
  udp {
    port => 5514
    codec => plain
    tags => ["syslog", "udp"]
  }

  # Optional: Beats input
  beats {
    port => 5044
    tags => ["beats"]
  }
}

filter {
  # Parse KillKrill-specific fields
  if "killkrill" in [tags] {
    # Ensure @timestamp is properly set
    if [timestamp] {
      date {
        match => [ "timestamp", "ISO8601" ]
        target => "@timestamp"
      }
    }

    # Parse labels if they exist
    if [labels] {
      json {
        source => "labels"
        target => "labels"
      }
    }

    # Parse tags if they exist
    if [tags_json] {
      json {
        source => "tags_json"
        target => "tags_array"
      }
      mutate {
        rename => { "tags_array" => "tags" }
      }
    }

    # Set log level field for ECS compliance
    if [log_level] {
      mutate {
        add_field => { "[log][level]" => "%{log_level}" }
      }
    } else if [severity] {
      mutate {
        add_field => { "[log][level]" => "%{severity}" }
      }
    }

    # Set service information
    if [service_name] {
      mutate {
        add_field => { "[service][name]" => "%{service_name}" }
        add_field => { "[service][type]" => "application" }
      }
    } else if [application] {
      mutate {
        add_field => { "[service][name]" => "%{application}" }
        add_field => { "[service][type]" => "application" }
      }
    }

    # Set host information
    if [hostname] {
      mutate {
        add_field => { "[host][name]" => "%{hostname}" }
      }
    }

    if [source_ip] {
      mutate {
        add_field => { "[host][ip]" => "%{source_ip}" }
        add_field => { "[source][ip]" => "%{source_ip}" }
      }
    }

    # Set ECS version
    mutate {
      add_field => { "[ecs][version]" => "8.0" }
    }

    # Set event information
    mutate {
      add_field => { "[event][dataset]" => "killkrill.logs" }
      add_field => { "[event][module]" => "killkrill" }
      add_field => { "[event][kind]" => "event" }
    }

    # Add ingestion timestamp
    ruby {
      code => "event.set('[event][ingested]', Time.now.utc.iso8601)"
    }

    # Set KillKrill-specific fields
    if [source_id] {
      mutate {
        add_field => { "[killkrill][source_id]" => "%{source_id}" }
      }
    }

    if [protocol] {
      mutate {
        add_field => { "[killkrill][protocol]" => "%{protocol}" }
      }
    }

    if [facility] {
      mutate {
        add_field => { "[killkrill][facility]" => "%{facility}" }
      }
    }

    if [raw_log] {
      mutate {
        add_field => { "[killkrill][raw_log]" => "%{raw_log}" }
      }
    }

    # Handle error information
    if [error_type] {
      mutate {
        add_field => { "[error][type]" => "%{error_type}" }
      }
    }

    if [error_message] {
      mutate {
        add_field => { "[error][message]" => "%{error_message}" }
      }
    }

    if [error_stack_trace] {
      mutate {
        add_field => { "[error][stack_trace]" => "%{error_stack_trace}" }
      }
    }

    # Handle trace information
    if [trace_id] {
      mutate {
        add_field => { "[trace][id]" => "%{trace_id}" }
      }
    }

    if [span_id] {
      mutate {
        add_field => { "[trace][span][id]" => "%{span_id}" }
      }
    }

    if [transaction_id] {
      mutate {
        add_field => { "[trace][transaction][id]" => "%{transaction_id}" }
      }
    }
  }

  # Handle syslog messages
  if "syslog" in [tags] {
    grok {
      match => {
        "message" => "<%{NONNEGINT:priority}>%{SYSLOGTIMESTAMP:timestamp} %{IPORHOST:hostname} %{PROG:program}(?:\[%{POSINT:pid}\])?: %{GREEDYDATA:syslog_message}"
      }
    }

    date {
      match => [ "timestamp", "MMM  d HH:mm:ss", "MMM dd HH:mm:ss" ]
    }

    mutate {
      add_field => { "[log][level]" => "info" }
      add_field => { "[service][name]" => "%{program}" }
      add_field => { "[host][name]" => "%{hostname}" }
      add_field => { "[ecs][version]" => "8.0" }
      add_field => { "[event][dataset]" => "syslog" }
      rename => { "syslog_message" => "message" }
    }
  }

  # Geoip enrichment for source IPs
  if [source][ip] {
    geoip {
      source => "[source][ip]"
      target => "[source][geo]"
    }
  }

  # Remove temporary fields
  mutate {
    remove_field => [
      "timestamp", "log_level", "service_name", "application",
      "hostname", "source_ip", "protocol", "facility", "raw_log",
      "error_type", "error_message", "error_stack_trace",
      "trace_id", "span_id", "transaction_id", "labels", "tags_json",
      "priority", "program", "pid"
    ]
  }
}

output {
  # Output to Elasticsearch with daily indices
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "killkrill-logs-%{+YYYY.MM.dd}"

    # Use document ID to prevent duplicates
    document_id => "%{[@metadata][redis_stream_id]}"

    # Template management
    template_name => "killkrill-logs"
    template_pattern => "killkrill-logs-*"
    template => "/usr/share/logstash/templates/killkrill-logs.json"
    template_overwrite => true

    # Performance settings
    pool_max => 50
    pool_max_per_route => 10

    # Retry settings
    retry_max_interval => 5
    retry_max_items => 1000
  }

  # Debug output (remove in production)
  if [@metadata][debug] {
    stdout {
      codec => rubydebug
    }
  }

  # Optional: Send metrics to Prometheus
  # This would require a Prometheus output plugin
}

# Dead letter queue for failed events
# Events that fail processing will be sent here for investigation
if [@metadata][dead_letter_queue] {
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "killkrill-dlq-%{+YYYY.MM.dd}"
    document_id => "%{[@metadata][redis_stream_id]}"
  }
}